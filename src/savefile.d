/*
 * Copyright 2015-2019 Philip Pavlick
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * 
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

// savefile.d:  Functions for reading and writing dungeon level files

import global;

import std.stdio;
import std.format;
import std.file;
import std.exception : basicExceptionCtors;

/++
 + An exception for invalid save file access
 +
 + See_Also:
 +   <a href="#save_error">save_error</a>,
 +   <a href="#DungeonFileException">DungeonFileException</a>
 +/
class SaveFileException : Exception
{
  mixin basicExceptionCtors;
}

/++
 + An exception for invalid dungeon level file access
 +
 + See_Also:
 +   <a href="#level_file_error">level_file_error</a>
 +   <a href="#SaveFileException">SaveFileException</a>
 +/
class DungeonFileException : Exception
{
  mixin basicExceptionCtors;
}

/++
 + Throws a SaveFileException
 +
 + This function throws a SaveFileException with the given error message.
 +
 + The message thrown will always be: "Unable to access save file (1): (2)",
 + where (1) is `save_file` and (2) is `error`
 +
 + See_Also:
 +     <a href="#level_file_error">level_file_error</a>
 +
 + Throws:
 +     SaveFileException
 +
 + Params:
 +     file = The path to the file that caused the error
 +     args = The format arguments for the message to be appended to the
 +            thrown `SaveFileException`
 +/
void save_error( T... )( string file, T args )
{
  throw new SaveFileException( format( "Unable to access save file %s: %s",
                                       file, format( args ) ) );
}

/++
 + Throws a DungeonFileException
 +
 + This function throws a DungeonFileException with the given error message.
 +
 + The message thrown will always be: "Unable to access dungeon level file
 + (1): (2)", where (1) is `dungeon_file` and (2) is `error`
 +
 + See_Also:
 +     <a href="#save_error">save_error</a>
 +
 + Throws:
 +     DungeonFileException
 +
 + Params:
 +     dungeon_file = The path to the file that caused the error
 +     args         = The format arguments for the message to be appended to
 +                    the thrown `SaveFileException`
 +/
void level_file_error( T... )( string dungeon_file, T args )
{
  throw new DungeonFileException(
    format( "Unable to read dungeon level file %s: %s",
    dungeon_file, format( args ) ) );
}

/++
 + Opens a level from a file.
 +
 + This function opens a level from a file.  The file is specified by the
 + given integer level_number.  The file will have the file name
 + `save/lev/<level_number>.lev`
 +
 + The file is always opened in "read mode," because this function is only
 + intended to <i>access</i> files, not save them.
 +
 + Deprecated:
 +     This function is not currently in use.  Use `level_from_file` instead.
 +
 + Throws:
 +     DungeonFileException if the dungeon file does not exist or is
 +     inaccessible
 +
 + See_Also:
 +      <a href="#level_from_file">level_from_file</a>,
 +      <a href="#save_level">save_level</a>
 +
 + Params:
 +     args = Format arguments representing the file name for the level to be
 +            opened
 +
 + Returns: A `File` opened by the function.
 +/
File open_level( T... )( T args )
{
  string path = format( "save/lev/%s.lev", format( args ) );

  // Check if the file exists; if it doesn't, throw an exception
  if( !exists( path ) )
  { level_file_error( path, "File does not exist." );
  }

  if( !isFile( path ) )
  { level_file_error( path, "This is a directory or symlink, not a file" );
  }

  File ret;

  try
  {
    ret = File( path, "r" );
  }
  catch( FileException e )
  {
    level_file_error( path, e.msg );
  }

  return ret;
}

/++
 + Saves a level to a file
 +
 + This function takes in a `Map` and a `Player` and writes the map data and
 + the player's coordinates to a file.  The file is specified by a name
 + generated by the format args taken in by the function.  The file will
 + always be saved in "save/lev/`format( args )`.lev".
 +
 + The file is accessed in "write mode," and will overwrite any existing file.
 +
 + See_Also:
 +     <a href="#level_from_file">level_from_file</a>
 +
 + Throws:
 +     DungeonFileException if the file path is inaccessible,
 +     FileException if some other problem happened while writing.
 +
 + Params:
 +     m    = The `Map` to be saved
 +     u    = The `Player` character
 +     args = Format arguments for the file name to be saved to, not including
 +            the directory or the .lev identifier
 +/
void save_level( T... )( Map m, Player u, T args )
{
  File fil;
  string path = format( "save/lev/%s.lev", format( args ) );

  mkdirRecurse( "save/lev" );

  if( exists( path ) && !isFile( path ) )
  {
    level_file_error( path,
                      "This file name points to a directory or symlink" );
  }

  try
  {
    fil = File( path, "w" );
  }
  catch( FileException e )
  {
    level_file_error( path, e.msg );
  }

  // First things first: Output the version number so that we can determine
  // level file compatibility:
  string ver = format( "%.3f", VERSION );
  fil.writeln( VERSION );

  // We start by recording all of the tiles on the map:

  // Leave a marker indicating we're starting tile recording:
  fil.writeln( cast(char)20 );

  foreach( y; 0 .. MAP_Y )
  {
    foreach( x; 0 .. MAP_X )
    {
      Tile t = m.t[y][x];

      // Each tile has a symbol...
      Symbol s = t.sym;

      char ch = s.ch;
      fil.writeln( ch );

      // Each symbol has a Color...
      Color c = s.color;

      uint fg = c.fg;
      fil.writeln( fg );

      bool reverse = c.reverse;
      fil.writeln( reverse );

      // Each tile also has a series of booleans:
      bool block_c = t.block_cardinal_movement,
           block_d = t.block_diagonal_movement,
           block_v = t.block_vision,
           lit = t.lit, seen = t.seen;
      fil.writeln( block_c );
      fil.writeln( block_d );
      fil.writeln( block_v );
      fil.writeln( lit );
      fil.writeln( seen );

      uint hazard = t.hazard;
      fil.writeln( hazard );

      // We're done with this tile.
    } // foreach( x; 0 .. MAP_X )
  } // foreach( y; 0 .. MAP_Y )

  // Leave a marker indicating that we're finishing tile output and starting
  // items:
  fil.writeln( cast(char)20 );

  // Start writing items:
  foreach( y; 0 .. MAP_Y )
  {
    foreach( x; 0 .. MAP_X )
    {
      Item i = m.i[y][x];

      // Every item has a symbol:
      Symbol s = i.sym;

      // Unlike with the tiles, if the symbol's character is equal to '\0' we
      // actually just output a marker and then continue, because that
      // indicates that there's no item there.
      if( s.ch == '\0' )
      {
        fil.writeln( cast(char)19 );
        continue;
      }

      // Otherwise, we treat this symbol much like the tile's symbol:

      char ch = s.ch;
      fil.writeln( ch );

      Color c = s.color;

      uint fg = c.fg;
      fil.writeln( fg );

      bool reverse = c.reverse;
      fil.writeln( reverse );

      // Each item has a name...
      string name = i.name;
      fil.writeln( name );

      uint type = i.type, equip = i.equip;
      fil.writeln( type );
      fil.writeln( equip );

      int addd = i.addd, addm = i.addm;
      fil.writeln( addd );
      fil.writeln( addm );

      // We're done with the item.
    } // foreach( x; 0 .. MAP_X )
  } // foreach( y; 0 .. MAP_Y )

  // Leave a marker indicating that we're done with items and now are
  // outputting monsters
  fil.writeln( cast(char)20 );

  // Start writing monsters:
  foreach( n; 0 .. m.m.length )
  {
    Monst mn = m.m[n];

    // If the monster has no hit points, skip it... dead monsters aren't worth
    // recording.
    if( mn.hp <= 0 )
    { continue;
    }

    // Every monster has--you guessed it!  A symbol!
    Symbol s = mn.sym;

    char ch = s.ch;
    fil.writeln( ch );

    Color c = s.color;

    uint fg = c.fg;
    fil.writeln( fg );

    bool reverse = c.reverse;
    fil.writeln( reverse );

    // Every monster has a string...
    string name = mn.name;
    fil.writeln( name );

    int hp = mn.hp;
    fil.writeln( hp );

    uint fly = mn.fly, swim = mn.swim, x = mn.x, y = mn.y;
    fil.writeln( fly );
    fil.writeln( swim );
    fil.writeln( x );
    fil.writeln( y );

    // Every monster has a dicebag...
    Dicebag db = mn.attack_roll;

    uint di = db.dice;
    fil.writeln( di );

    int modifier = db.modifier;
    fil.writeln( modifier );

    int floor = db.floor, ceiling = db.ceiling;
    fil.writeln( floor );
    fil.writeln( ceiling );

    // We're done with the monster.
  } // foreach( n; 0 .. m.m.length )

  // Leave a marker indicating that we're done with outputting monsters
  fil.writeln( cast(char)20 );

  // Finally, we output the coordinates that the player character is standing
  // at.
  ubyte x = u.x, y = u.y;

  fil.writeln( x );
  fil.writeln( y );

  // We're done.
  fil.close();
} // save_level( map, player, uint )

/++
 + Get a saved level from a file
 +
 + This function reads in a level file and populates a map based on its
 + contents.  The file will always be searched for in
 + "save/lev/`file_label`.lev".
 +
 + See_Also:
 +     <a href="#save_level">save_level</a>
 +
 + Throws:
 +     DungeonFileException if the given file is missing or inaccessible.
 +
 + Params:
 +     file_label = The file name of the file which is to be read, not
 +                  including the directory or the .lev identifier.
 +
 + Returns:
 +     A `map` populated from the data read in from the file.
 +/
Map level_from_file( string file_label )
{
  import std.conv;

  string path = format( "save/lev/%s.lev", file_label );

  if( !exists( path ) )
  { level_file_error( path, "File does not exist." );
  }

  if( !isFile( path ) )
  { level_file_error( path, "This is a directory or a symlink, not a file." );
  }

  File fil;

  try
  {
    fil = File( path, "r" );
  }
  catch( FileException e )
  {
    level_file_error( path, e.msg );
  }

  float ver = 0.000;

  ver = to!float( strip_line( fil ) );

  if( ver < 0.026 )
  {
    fil.close();
    level_file_error( path, "File version %.3f not compatible with current "
                      ~ "version %.3f", ver, VERSION );
  }

  char marker = '\0';

  marker = to!char( strip_line( fil ) );

  if( marker != cast(char)20 )
  {
    fil.close();
    level_file_error( path,
                  "Could not read map tiles; file not formatted correctly." );
  }

  Map m;

  foreach( y; 0 .. MAP_Y )
  {
    foreach( x; 0 .. MAP_X )
    {
      Tile t;

      char ch = '?';
      uint fg = CLR_LITERED;
      bool reversed = 1;


      ch = to!char( strip_line( fil ) );
      fg = to!uint( strip_line( fil ) );
      reversed = to!bool( strip_line( fil ) );

      t.sym.ch = ch;
      t.sym.color.fg = fg;
      t.sym.color.reverse = reversed;

      bool block_c = 1, block_d = 1, block_v = 1, lit = 0, seen = 0;

      block_c = to!bool( strip_line( fil ) );
      block_d = to!bool( strip_line( fil ) );
      block_v = to!bool( strip_line( fil ) );
      lit =     to!bool( strip_line( fil ) );
      seen =    to!bool( strip_line( fil ) );

      t.block_cardinal_movement = block_c;
      t.block_diagonal_movement = block_d;
      t.block_vision = block_v;
      t.lit = lit;
      t.seen = seen;

      uint hazard = 0;

      hazard = to!uint( strip_line( fil ) );

      t.hazard = hazard;

      m.t[y][x] = t;
    } // foreach( x; 0 .. MAP_X )
  } // foreach( y; 0 .. MAP_Y )

  marker = to!char( strip_line( fil ) );

  if( marker != cast(char)20 )
  {
    fil.close();
    level_file_error( path,
                  "Could not read items; file not formatted correctly." );
  }

  foreach( y; 0 .. MAP_Y )
  {
    foreach( x; 0 .. MAP_X )
    {
      char ch = '\0';

      ch = to!char( strip_line( fil ) );

      if( ch == cast(char)19 )
      {
        m.i[y][x] = No_item;
        continue;
      }

      Item i;

      uint fg = CLR_LITERED;
      bool reversed = 1;

      fg = to!uint( strip_line( fil ) );
      reversed = to!bool( strip_line( fil ) );

      i.sym.ch = ch;
      i.sym.color.fg = fg;
      i.sym.color.reverse = reversed;

      string name = strip_line( fil );

      i.name = name;

      uint type = 0, equip = 0;

      type = to!uint( strip_line( fil ) );
      equip = to!uint( strip_line( fil ) );

      i.type = type;
      i.equip = equip;

      int addd = 0, addm = 0;

      addd = to!int( strip_line( fil ) );
      addm = to!int( strip_line( fil ) );

      i.addd = addd;
      i.addm = addm;

      m.i[y][x] = i;
    } // foreach( x; 0 .. MAP_X )
  } // foreach( y; 0 .. MAP_Y )

  marker = to!char( strip_line( fil ) );

  if( marker != cast(char)20 )
  {
    fil.close();
    level_file_error( path,
                  "Could not read monsters; file not formatted correctly." );
  }

  char ch = '\0';
  uint count = 0;

  ch = to!char( strip_line( fil ) );

  while( ch != cast(char)20 )
  {
    if( fil.eof() )
    {
      fil.close();
      level_file_error( path, "Reached EOF before end of monster array" );
    }

    Monst mn;

    uint fg = CLR_LITERED;
    bool reversed = 1;

    fg = to!uint( strip_line( fil ) );
    reversed = to!bool( strip_line( fil ) );

    mn.sym.ch = ch;
    mn.sym.color.fg = fg;
    mn.sym.color.reverse = reversed;

    string name = strip_line( fil );
 
    mn.name = name;

    int hp = 0;

    hp = to!int( strip_line( fil ) );

    mn.hp = hp;

    uint fly = 0, swim = 0;

    fly = to!uint( strip_line( fil ) );
    swim = to!uint( strip_line( fil ) );

    mn.fly = fly;
    mn.swim = swim;

    ubyte x = 0, y = 0;

    x = to!ubyte( strip_line( fil ) );
    y = to!ubyte( strip_line( fil ) );

    uint di = 0;

    di = to!uint( strip_line( fil ) );

    mn.attack_roll.dice = di;

    int modifier = 0;

    modifier = to!int( strip_line( fil ) );

    mn.attack_roll.modifier = modifier;

    int floor = 1000, ceiling = 0;

    floor = to!int( strip_line( fil ) );
    ceiling = to!int( strip_line( fil ) );

    mn.attack_roll.floor = floor;
    mn.attack_roll.ceiling = ceiling;

    mn.x = x;
    mn.y = y;

    m.m.length++;
    m.m[count] = mn;
    count++;

    ch = to!char( strip_line( fil ) );
  }

  ubyte px = 0, py = 0;

  px = to!ubyte( strip_line( fil ) );
  py = to!ubyte( strip_line( fil ) );

  m.player_start = [ py, px ];

  fil.close();

  return m;
} // level_from_file( string )
